// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/valhalla_actor.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class ValhallaFlutterBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ValhallaFlutterBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ValhallaFlutterBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ValhallaActor> valhalla_actor_create(
    ffi.Pointer<ffi.Char> config_string,
  ) {
    return _valhalla_actor_create(
      config_string,
    );
  }

  late final _valhalla_actor_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ValhallaActor> Function(
              ffi.Pointer<ffi.Char>)>>('valhalla_actor_create');
  late final _valhalla_actor_create = _valhalla_actor_createPtr
      .asFunction<ffi.Pointer<ValhallaActor> Function(ffi.Pointer<ffi.Char>)>();

  void valhalla_actor_destroy(
    ffi.Pointer<ValhallaActor> a,
  ) {
    return _valhalla_actor_destroy(
      a,
    );
  }

  late final _valhalla_actor_destroyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ValhallaActor>)>>(
      'valhalla_actor_destroy');
  late final _valhalla_actor_destroy = _valhalla_actor_destroyPtr
      .asFunction<void Function(ffi.Pointer<ValhallaActor>)>();

  ffi.Pointer<ffi.Char> valhalla_actor_act(
    ffi.Pointer<ValhallaActor> a,
    ValhallaAction action,
    ffi.Pointer<ffi.Char> request,
  ) {
    return _valhalla_actor_act(
      a,
      action.value,
      request,
    );
  }

  late final _valhalla_actor_actPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ValhallaActor>,
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>>('valhalla_actor_act');
  late final _valhalla_actor_act = _valhalla_actor_actPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ValhallaActor>, int, ffi.Pointer<ffi.Char>)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final ValhallaFlutterBindings _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ValhallaActor>)>>
      get valhalla_actor_destroy => _library._valhalla_actor_destroyPtr;
}

enum ValhallaAction {
  ROUTE(0),
  LOCATE(1),
  SOURCES_TO_TARGETS(2),
  OPTIMIZED_ROUTE(3),
  ISOCHRONE(4),
  TRACE_ROUTE(5),
  TRACE_ATTRIBUTES(6),
  HEIGHT(7),
  TRANSIT_AVAILABLE(8),
  EXPANSION(9),
  STATUS(10);

  final int value;
  const ValhallaAction(this.value);

  static ValhallaAction fromValue(int value) => switch (value) {
        0 => ROUTE,
        1 => LOCATE,
        2 => SOURCES_TO_TARGETS,
        3 => OPTIMIZED_ROUTE,
        4 => ISOCHRONE,
        5 => TRACE_ROUTE,
        6 => TRACE_ATTRIBUTES,
        7 => HEIGHT,
        8 => TRANSIT_AVAILABLE,
        9 => EXPANSION,
        10 => STATUS,
        _ => throw ArgumentError("Unknown value for ValhallaAction: $value"),
      };
}

final class ValhallaActor extends ffi.Opaque {}
